# SonarQube가 검출할 취약한 코드 예시

## 취약점 1: SQL Injection (javascript:S5144)

### ❌ 취약한 코드
```javascript
// backend/server.js에 추가할 취약한 코드
app.post('/api/test/search', async (req, res) => {
  const { keyword } = req.body;
  // 직접 쿼리 문자열에 사용자 입력 삽입 (위험!)
  const query = `SELECT * FROM posts WHERE title LIKE '%${keyword}%'`;
  // 실제로는 MongoDB를 사용하지만, SonarQube가 패턴을 감지함
  res.json({ message: "This is vulnerable code for testing", query: query });
});
```

### ✅ 수정된 코드
```javascript
// 파라미터화된 쿼리 사용
app.post('/api/test/search', async (req, res) => {
  const { keyword } = req.body;
  // 파라미터화된 쿼리 사용 (안전)
  const query = 'SELECT * FROM posts WHERE title LIKE ?';
  const result = await db.query(query, [`%${keyword}%`]);
  res.json({ message: "This is secure code", result: result });
});

// 또는 해당 엔드포인트 제거 (MongoDB를 사용하는 경우)
```

---

## 취약점 2: 하드코딩된 비밀번호 (javascript:S2068)

### ❌ 취약한 코드
```javascript
// backend/server.js에 추가할 취약한 코드
const TEST_ADMIN_PASSWORD = "admin123";
app.post('/api/test/admin', async (req, res) => {
  const { password } = req.body;
  if (password === TEST_ADMIN_PASSWORD) {
    res.json({ success: true, message: "Admin access granted" });
  } else {
    res.json({ success: false, message: "Invalid password" });
  }
});
```

### ✅ 수정된 코드
```javascript
// 환경 변수 사용
const TEST_ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || '';
app.post('/api/test/admin', async (req, res) => {
  const { password } = req.body;
  if (password === TEST_ADMIN_PASSWORD) {
    res.json({ success: true, message: "Admin access granted" });
  } else {
    res.json({ success: false, message: "Invalid password" });
  }
});

// 또는 해당 엔드포인트 제거
```

---

## 취약점 3: 민감 정보 로깅 (javascript:S4792)

### ❌ 취약한 코드
```javascript
// backend/server.js에 추가할 취약한 코드
app.post('/api/test/login', async (req, res) => {
  const { username, password } = req.body;
  // 민감 정보 로깅 (위험!)
  console.log("User login:", username, password);
  res.json({ success: true, message: "Login successful" });
});
```

### ✅ 수정된 코드
```javascript
// 민감 정보 제외
app.post('/api/test/login', async (req, res) => {
  const { username, password } = req.body;
  // 비밀번호 제외하고 로깅
  console.log("User login:", username);
  res.json({ success: true, message: "Login successful" });
});
```

---

## 취약점 4: MongoDB 연결 문자열에 하드코딩된 비밀번호

### ❌ 취약한 코드
```javascript
// backend/server.js에 이미 있는 코드 (31번째 줄)
mongoose.connect("mongodb+srv://errorAdmin:pass123%23@errorarchive.bjd5r0c.mongodb.net/errorArch?retryWrites=true&w=majority")
```

### ✅ 수정된 코드
```javascript
// 환경 변수 사용
const MONGODB_URI = process.env.MONGODB_URI || "mongodb+srv://errorAdmin:pass123%23@errorarchive.bjd5r0c.mongodb.net/errorArch?retryWrites=true&w=majority";
mongoose.connect(MONGODB_URI)
```

---

## 취약점 5: PW 찾기에서 비밀번호 노출

### ❌ 취약한 코드
```javascript
// backend/server.js에 이미 있는 코드 (334번째 줄)
res.json({ success: true, message: `해당 계정의 비밀번호는 ${user.password} 입니다.` });
```

### ✅ 수정된 코드
```javascript
// 비밀번호를 직접 노출하지 않고 재설정 링크 전송
res.json({ success: true, message: "비밀번호 재설정 링크를 이메일로 전송했습니다." });
// 실제로는 이메일로 재설정 링크를 보내야 함
```

---

## 취약한 코드 추가 방법

### 방법 1: server.js 파일에 직접 추가
```bash
cd /home/kevin/error-archive/backend

# 취약한 코드 추가
cat >> server.js << 'EOF'

// ===============================
// ❌ 취약한 코드 (SonarQube 테스트용)
// ===============================

// SQL Injection 취약점 예시
app.post('/api/test/search', async (req, res) => {
  const { keyword } = req.body;
  const query = `SELECT * FROM posts WHERE title LIKE '%${keyword}%'`;
  res.json({ message: "This is vulnerable code for testing", query: query });
});

// 하드코딩된 비밀번호
const TEST_ADMIN_PASSWORD = "admin123";
app.post('/api/test/admin', async (req, res) => {
  const { password } = req.body;
  if (password === TEST_ADMIN_PASSWORD) {
    res.json({ success: true, message: "Admin access granted" });
  } else {
    res.json({ success: false, message: "Invalid password" });
  }
});

// 민감 정보 로깅
app.post('/api/test/login', async (req, res) => {
  const { username, password } = req.body;
  console.log("User login:", username, password);
  res.json({ success: true, message: "Login successful" });
});
EOF
```

### 방법 2: 별도 파일로 생성 후 import
```bash
# 취약한 코드를 별도 파일로 생성
cat > backend/vulnerable-routes.js << 'EOF'
// 취약한 라우트 예시
module.exports = (app) => {
  // SQL Injection
  app.post('/api/test/search', async (req, res) => {
    const { keyword } = req.body;
    const query = `SELECT * FROM posts WHERE title LIKE '%${keyword}%'`;
    res.json({ query: query });
  });
  
  // 하드코딩된 비밀번호
  const ADMIN_PASSWORD = "admin123";
  app.post('/api/test/admin', async (req, res) => {
    const { password } = req.body;
    if (password === ADMIN_PASSWORD) {
      res.json({ success: true });
    }
  });
};
EOF

# server.js에서 import
# const vulnerableRoutes = require('./vulnerable-routes');
# vulnerableRoutes(app);
```

---

## 취약점 수정 방법

### 전체 취약한 코드 제거
```bash
cd /home/kevin/error-archive/backend

# 취약한 코드 섹션 제거
sed -i '/\/\/ ❌ 취약한 코드 (SonarQube 테스트용)/,/^});$/d' server.js

# 또는 수동으로 편집
vi server.js
# 취약한 코드 부분 삭제
```

### 개별 취약점 수정
```bash
# SQL Injection 수정
sed -i "s/\`SELECT \* FROM posts WHERE title LIKE '%\${keyword}%'\`/'SELECT * FROM posts WHERE title LIKE ?'/g" server.js

# 하드코딩된 비밀번호 수정
sed -i 's/const TEST_ADMIN_PASSWORD = "admin123";/const TEST_ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "";/g' server.js

# 민감 정보 로깅 수정
sed -i 's/console.log("User login:", username, password);/console.log("User login:", username);/g' server.js
```

---

## SonarQube가 검출하는 규칙

1. **javascript:S5144** - SQL Injection 취약점
2. **javascript:S2068** - 하드코딩된 비밀번호
3. **javascript:S4792** - 민감 정보 로깅
4. **javascript:S2083** - URL에 하드코딩된 자격 증명
5. **javascript:S1313** - 하드코딩된 IP 주소

각 규칙에 대한 상세 정보는 SonarQube 웹 UI에서 확인할 수 있습니다.

